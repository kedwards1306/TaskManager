{"version":3,"file":"previousTrace.js","sources":["../../../../src/tracing/previousTrace.ts"],"sourcesContent":["import type { Span } from '@sentry/core';\nimport { logger, SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE, spanToJSON, type SpanContextData } from '@sentry/core';\nimport { WINDOW } from '../exports';\nimport { DEBUG_BUILD } from '../debug-build';\n\nexport interface PreviousTraceInfo {\n  /**\n   * Span context of the previous trace's local root span\n   */\n  spanContext: SpanContextData;\n\n  /**\n   * Timestamp in seconds when the previous trace was started\n   */\n  startTimestamp: number;\n}\n\n// 1h in seconds\nexport const PREVIOUS_TRACE_MAX_DURATION = 3600;\n\n// session storage key\nexport const PREVIOUS_TRACE_KEY = 'sentry_previous_trace';\n\nexport const PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE = 'sentry.previous_trace';\n\n/**\n * Adds a previous_trace span link to the passed span if the passed\n * previousTraceInfo is still valid.\n *\n * @returns the updated previous trace info (based on the current span/trace) to\n * be used on the next call\n */\nexport function addPreviousTraceSpanLink(\n  previousTraceInfo: PreviousTraceInfo | undefined,\n  span: Span,\n): PreviousTraceInfo {\n  const spanJson = spanToJSON(span);\n\n  if (!previousTraceInfo) {\n    return {\n      spanContext: span.spanContext(),\n      startTimestamp: spanJson.start_timestamp,\n    };\n  }\n\n  const previousTraceSpanCtx = previousTraceInfo.spanContext;\n  if (previousTraceSpanCtx.traceId === spanJson.trace_id) {\n    // This means, we're still in the same trace so let's not update the previous trace info\n    // or add a link to the current span.\n    // Once we move away from the long-lived, route-based trace model, we can remove this cases\n    return previousTraceInfo;\n  }\n\n  // Only add the link if the startTimeStamp of the previous trace's root span is within\n  // PREVIOUS_TRACE_MAX_DURATION (1h) of the current root span's startTimestamp\n  // This is done to\n  // - avoid adding links to \"stale\" traces\n  // - enable more efficient querying for previous/next traces in Sentry\n  if (Date.now() / 1000 - previousTraceInfo.startTimestamp <= PREVIOUS_TRACE_MAX_DURATION) {\n    if (DEBUG_BUILD) {\n      logger.info(\n        `Adding previous_trace ${previousTraceSpanCtx} link to span ${{\n          op: spanJson.op,\n          ...span.spanContext(),\n        }}`,\n      );\n    }\n\n    span.addLink({\n      context: previousTraceSpanCtx,\n      attributes: {\n        [SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE]: 'previous_trace',\n      },\n    });\n\n    // TODO: Remove this once EAP can store span links. We currently only set this attribute so that we\n    // can obtain the previous trace information from the EAP store. Long-term, EAP will handle\n    // span links and then we should remove this again. Also throwing in a TODO(v10), to remind us\n    // to check this at v10 time :)\n    span.setAttribute(\n      PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE,\n      `${previousTraceSpanCtx.traceId}-${previousTraceSpanCtx.spanId}-${\n        previousTraceSpanCtx.traceFlags === 0x1 ? 1 : 0\n      }`,\n    );\n  }\n\n  return {\n    spanContext: span.spanContext(),\n    startTimestamp: spanToJSON(span).start_timestamp,\n  };\n}\n\n/**\n * Stores @param previousTraceInfo in sessionStorage.\n */\nexport function storePreviousTraceInSessionStorage(previousTraceInfo: PreviousTraceInfo): void {\n  try {\n    WINDOW.sessionStorage.setItem(PREVIOUS_TRACE_KEY, JSON.stringify(previousTraceInfo));\n  } catch (e) {\n    // Ignore potential errors (e.g. if sessionStorage is not available)\n    DEBUG_BUILD && logger.warn('Could not store previous trace in sessionStorage', e);\n  }\n}\n\n/**\n * Retrieves the previous trace from sessionStorage if available.\n */\nexport function getPreviousTraceFromSessionStorage(): PreviousTraceInfo | undefined {\n  try {\n    const previousTraceInfo = WINDOW.sessionStorage?.getItem(PREVIOUS_TRACE_KEY);\n    // @ts-expect-error - intentionally risking JSON.parse throwing when previousTraceInfo is null to save bundle size\n    return JSON.parse(previousTraceInfo);\n  } catch (e) {\n    return undefined;\n  }\n}\n"],"names":["spanToJSON","DEBUG_BUILD","logger","SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE","WINDOW"],"mappings":";;;;;;;;;;;;;;AAiBA;AACO,MAAM,2BAA4B,GAAE;;AAE3C;AACO,MAAM,kBAAmB,GAAE;;AAE3B,MAAM,iCAAkC,GAAE;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,wBAAwB;AACxC,EAAE,iBAAiB;AACnB,EAAE,IAAI;AACN,EAAqB;AACrB,EAAE,MAAM,QAAS,GAAEA,eAAU,CAAC,IAAI,CAAC;;AAEnC,EAAE,IAAI,CAAC,iBAAiB,EAAE;AAC1B,IAAI,OAAO;AACX,MAAM,WAAW,EAAE,IAAI,CAAC,WAAW,EAAE;AACrC,MAAM,cAAc,EAAE,QAAQ,CAAC,eAAe;AAC9C,KAAK;AACL;;AAEA,EAAE,MAAM,oBAAA,GAAuB,iBAAiB,CAAC,WAAW;AAC5D,EAAE,IAAI,oBAAoB,CAAC,YAAY,QAAQ,CAAC,QAAQ,EAAE;AAC1D;AACA;AACA;AACA,IAAI,OAAO,iBAAiB;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,IAAI,CAAC,GAAG,EAAC,GAAI,IAAA,GAAO,iBAAiB,CAAC,cAAe,IAAG,2BAA2B,EAAE;AAC3F,IAAI,IAAIC,sBAAW,EAAE;AACrB,MAAMC,WAAM,CAAC,IAAI;AACjB,QAAQ,CAAC,sBAAsB,EAAE,oBAAoB,CAAC,cAAc,EAAE;AACtE,UAAU,EAAE,EAAE,QAAQ,CAAC,EAAE;AACzB,UAAU,GAAG,IAAI,CAAC,WAAW,EAAE;AAC/B,SAAS,CAAC,CAAA;AACA,OAAA;AACA;;AAEA,IAAA,IAAA,CAAA,OAAA,CAAA;AACA,MAAA,OAAA,EAAA,oBAAA;AACA,MAAA,UAAA,EAAA;AACA,QAAA,CAAAC,sCAAA,GAAA,gBAAA;AACA,OAAA;AACA,KAAA,CAAA;;AAEA;AACA;AACA;AACA;AACA,IAAA,IAAA,CAAA,YAAA;AACA,MAAA,iCAAA;AACA,MAAA,CAAA,EAAA,oBAAA,CAAA,OAAA,CAAA,CAAA,EAAA,oBAAA,CAAA,MAAA,CAAA,CAAA;AACA,QAAA,oBAAA,CAAA,UAAA,KAAA,GAAA,GAAA,CAAA,GAAA;AACA,OAAA,CAAA;AACA,KAAA;AACA;;AAEA,EAAA,OAAA;AACA,IAAA,WAAA,EAAA,IAAA,CAAA,WAAA,EAAA;AACA,IAAA,cAAA,EAAAH,eAAA,CAAA,IAAA,CAAA,CAAA,eAAA;AACA,GAAA;AACA;;AAEA;AACA;AACA;AACA,SAAA,kCAAA,CAAA,iBAAA,EAAA;AACA,EAAA,IAAA;AACA,IAAAI,cAAA,CAAA,cAAA,CAAA,OAAA,CAAA,kBAAA,EAAA,IAAA,CAAA,SAAA,CAAA,iBAAA,CAAA,CAAA;AACA,GAAA,CAAA,OAAA,CAAA,EAAA;AACA;AACA,IAAAH,sBAAA,IAAAC,WAAA,CAAA,IAAA,CAAA,kDAAA,EAAA,CAAA,CAAA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAA,kCAAA,GAAA;AACA,EAAA,IAAA;AACA,IAAA,MAAA,iBAAA,GAAAE,cAAA,CAAA,cAAA,EAAA,OAAA,CAAA,kBAAA,CAAA;AACA;AACA,IAAA,OAAA,IAAA,CAAA,KAAA,CAAA,iBAAA,CAAA;AACA,GAAA,CAAA,OAAA,CAAA,EAAA;AACA,IAAA,OAAA,SAAA;AACA;AACA;;;;;;;;;"}